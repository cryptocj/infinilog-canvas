<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test</title>
    
    <style>
        body, html { 
            margin: 0; padding: 0; 
            overflow: hidden; 
            height: 100%; width: 100%; 
            background-color: #f9fafb; 
            font-family: sans-serif;
        }
        
        /* Typography - System Hand-drawn Fonts */
        .font-hand { 
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', cursive, sans-serif; 
        }
        
        /* Layout Utilities */
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .top-0 { top: 0; }
        .left-0 { left: 0; }
        .overflow-hidden { overflow: hidden; }
        
        /* Canvas Container */
        #container {
            cursor: grab;
            touch-action: none;
        }
        #container:active {
            cursor: grabbing;
        }
        #transform-layer {
            transform-origin: 0 0;
            will-change: transform;
        }
        svg { 
            display: block; 
            overflow: visible; 
            width: 100%; height: 100%;
        }

        /* Watermark Badge */
        .watermark {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            font-size: 0.875rem;
            color: #6b7280;
            pointer-events: none;
            user-select: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div id="container" class="w-full h-full relative">
        <div id="transform-layer" class="absolute top-0 left-0 w-full h-full">
            <svg id="canvas" class="w-full h-full"></svg>
        </div>
    </div>
    
    <div class="watermark">
        InfiniLog Static View
    </div>

<!-- Safe Data Injection -->
<script type="application/json" id="app-data">
[]
</script>

<script type="module">
    // --- Rendering Logic (Ported from utils.ts) ---
    const random = (seed) => {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    };

    const getOffset = (min, max, seed) => {
        return min + random(seed) * (max - min);
    };

    const getRoughRect = (w, h, seed, roughness, radius = 0) => {
        const r = Math.min(radius, Math.min(w, h) / 2);
        const ro = roughness || 0; 
        const o = (idx) => getOffset(-ro, ro, seed + idx);
        
        let path = `M ${r + o(1)} ${0 + o(2)} `;
        path += `L ${w - r + o(3)} ${0 + o(4)} `;
        
        if (r > 0) {
            path += `Q ${w + o(5)} ${0 + o(6)} ${w + o(7)} ${r + o(8)} `;
        } else {
            path += `L ${w + o(5)} ${0 + o(6)} `; 
            path += `L ${w + o(7)} ${0 + o(8)} `;
        }

        path += `L ${w + o(9)} ${h - r + o(10)} `;
        
        if (r > 0) {
            path += `Q ${w + o(11)} ${h + o(12)} ${w - r + o(13)} ${h + o(14)} `;
        } else {
            path += `L ${w + o(11)} ${h + o(12)} `;
            path += `L ${w + o(13)} ${h + o(14)} `;
        }

        path += `L ${r + o(15)} ${h + o(16)} `;

        if (r > 0) {
            path += `Q ${0 + o(17)} ${h + o(18)} ${0 + o(19)} ${h - r + o(20)} `;
        } else {
            path += `L ${0 + o(17)} ${h + o(18)} `;
            path += `L ${0 + o(19)} ${h + o(20)} `;
        }

        path += `L ${0 + o(21)} ${r + o(22)} `;

        if (r > 0) {
            path += `Q ${0 + o(23)} ${0 + o(24)} ${r + o(25)} ${0 + o(26)} `;
        } else {
            path += `L ${0 + o(23)} ${0 + o(24)} `;
            path += `L ${r + o(25)} ${0 + o(26)} `;
        }
        
        path += "Z";
        return path;
    };
    
    const getRoughCircle = (w, h, seed, roughness) => {
         const r = (Math.min(w, h) * 0.02) * (roughness || 0); 
         const rx = w / 2; const ry = h / 2;
         const o = (idx) => getOffset(-r, r, seed + idx);
         
         let path = `M ${rx + o(1)} ${0 + o(2)} `;
         path += `C ${rx * 1.5 + o(3)} ${0 + o(4)}, ${w + o(5)} ${ry * 0.5 + o(6)}, ${w + o(7)} ${ry + o(8)} `;
         path += `C ${w + o(9)} ${ry * 1.5 + o(10)}, ${rx * 1.5 + o(11)} ${h + o(12)}, ${rx + o(13)} ${h + o(14)} `;
         path += `C ${rx * 0.5 + o(15)} ${h + o(16)}, ${0 + o(17)} ${ry * 1.5 + o(18)}, ${0 + o(19)} ${ry + o(20)} `;
         path += `C ${0 + o(21)} ${ry * 0.5 + o(22)}, ${rx * 0.5 + o(23)} ${0 + o(24)}, ${rx + o(25)} ${0 + o(26)} `;
         
         if (roughness > 0) {
             const s2 = seed + 100;
             const o2 = (idx) => getOffset(-r, r, s2 + idx);
             path += `M ${rx + o2(1)} ${0 + o2(2)} `;
             path += `C ${rx * 1.5 + o2(3)} ${0 + o2(4)}, ${w + o2(5)} ${ry * 0.5 + o2(6)}, ${w + o2(7)} ${ry + o2(8)} `;
             path += `C ${w + o2(9)} ${ry * 1.5 + o2(10)}, ${rx * 1.5 + o2(11)} ${h + o2(12)}, ${rx + o2(13)} ${h + o2(14)} `;
             path += `C ${rx * 0.5 + o2(15)} ${h + o2(16)}, ${0 + o2(17)} ${ry * 1.5 + o2(18)}, ${0 + o2(19)} ${ry + o2(20)} `;
             path += `C ${0 + o2(21)} ${ry * 0.5 + o2(22)}, ${rx * 0.5 + o2(23)} ${0 + o2(24)}, ${rx + o2(25)} ${0 + o2(26)} `;
         }
         return path;
    };
    
    const getRoughLine = (x1, y1, x2, y2, seed, strokeWidth, roughness) => {
        const r = roughness || 0; 
        let path = `M ${x1 + getOffset(-r, r, seed)} ${y1 + getOffset(-r, r, seed+1)} `;
        path += `Q ${x1 + (x2-x1)/2 + getOffset(-r, r, seed+2)} ${y1 + (y2-y1)/2 + getOffset(-r, r, seed+3)} `;
        path += `${x2 + getOffset(-r, r, seed+4)} ${y2 + getOffset(-r, r, seed+5)} `;

        if (strokeWidth > 1 && roughness > 0) {
             path += `M ${x1 + getOffset(-r, r, seed+6)} ${y1 + getOffset(-r, r, seed+7)} `;
             path += `Q ${x1 + (x2-x1)/2 + getOffset(-r, r, seed+8)} ${y1 + (y2-y1)/2 + getOffset(-r, r, seed+9)} `;
             path += `${x2 + getOffset(-r, r, seed+10)} ${y2 + getOffset(-r, r, seed+11)} `;
        }
        return path;
    };

    // Flat Rendering
    const getFlatCircle = (width, height) => {
        const rx = width / 2;
        const ry = height / 2;
        const cx = width / 2;
        const cy = height / 2;
        return `M ${cx - rx}, ${cy} a ${rx},${ry} 0 1,0 ${rx * 2},0 a ${rx},${ry} 0 1,0 -${rx * 2},0`;
    };

    const getFlatRect = (width, height, radius = 0) => {
        const r = Math.min(radius, Math.min(width, height) / 2);
        return `M ${r} 0 L ${width - r} 0 Q ${width} 0 ${width} ${r} L ${width} ${height - r} Q ${width} ${height} ${width - r} ${height} L ${r} ${height} Q 0 ${height} 0 ${height - r} L 0 ${r} Q 0 0 ${r} 0 Z`;
    };

    const getPath = (el) => {
        const w = el.width || 0;
        const h = el.height || 0;
        const seed = el.seed || 1;
        const rough = typeof el.roughness === 'number' ? el.roughness : 1;
        const corner = el.cornerRadius || 0;
        const style = el.renderStyle || 'sketchy';
        
        if (el.type === 'rectangle' || el.type === 'mindmap') {
            if (style === 'flat') return getFlatRect(w, h, corner);
            return getRoughRect(w, h, seed, rough, corner);
        }
        if (el.type === 'circle') {
            if (style === 'flat') return getFlatCircle(w, h);
            return getRoughCircle(w, h, seed, rough);
        }
        
        if (el.type === 'arrow' || el.type === 'pencil') {
            if (!el.points || el.points.length < 2) return "";
            let path = "";
            
            if (style === 'flat') {
                path = `M ${el.points[0].x} ${el.points[0].y} `;
                for (let i = 1; i < el.points.length; i++) {
                    path += `L ${el.points[i].x} ${el.points[i].y} `;
                }
                if (el.type === 'arrow') {
                    const end = el.points[el.points.length - 1];
                    const prev = el.points[el.points.length - 2];
                    const dx = end.x - prev.x;
                    const dy = end.y - prev.y;
                    const angle = Math.atan2(dy, dx);
                    const headLen = 15;
                    const p1 = { x: end.x - headLen * Math.cos(angle - Math.PI/6), y: end.y - headLen * Math.sin(angle - Math.PI/6) };
                    const p2 = { x: end.x - headLen * Math.cos(angle + Math.PI/6), y: end.y - headLen * Math.sin(angle + Math.PI/6) };
                    path += `M ${end.x} ${end.y} L ${p1.x} ${p1.y} `;
                    path += `M ${end.x} ${end.y} L ${p2.x} ${p2.y} `;
                }
            } else {
                for (let i = 0; i < el.points.length - 1; i++) {
                    const p1 = el.points[i];
                    const p2 = el.points[i+1];
                    path += getRoughLine(p1.x, p1.y, p2.x, p2.y, seed + i*10, el.strokeWidth || 2, rough);
                }
                if (el.type === 'arrow') {
                     const end = el.points[el.points.length - 1];
                     const prev = el.points[el.points.length - 2];
                     const dx = end.x - prev.x;
                     const dy = end.y - prev.y;
                     const angle = Math.atan2(dy, dx);
                     const headLen = 15;
                     const p1 = { x: end.x - headLen * Math.cos(angle - Math.PI/6), y: end.y - headLen * Math.sin(angle - Math.PI/6) };
                     const p2 = { x: end.x - headLen * Math.cos(angle + Math.PI/6), y: end.y - headLen * Math.sin(angle + Math.PI/6) };
                     path += getRoughLine(end.x, end.y, p1.x, p1.y, seed + 999, el.strokeWidth || 2, rough);
                     path += getRoughLine(end.x, end.y, p2.x, p2.y, seed + 1000, el.strokeWidth || 2, rough);
                }
            }
            return path;
        }
        return "";
    };

    // --- Markdown/Code Logic ---
    const renderMarkdown = (text, color) => {
        if (!text) return "";
        let html = text
            .replace(/</g, '&lt;').replace(/>/g, '&gt;') // Escape HTML
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/\`\`\`([\s\S]*?)\`\`\`/g, '<pre style="background:#f3f4f6; padding:8px; border-radius:4px; font-family:monospace; font-size:0.8em; overflow-x:auto;">$1</pre>');
            
        // Use standard newline splitting
        return html.split('\n').map(line => `<div>${line || '<br/>'}</div>`).join('');
    };

    // --- MAIN RENDER LOOP ---
    const init = async () => {
        console.log("Initializing InfiniLog Viewer...");
        
        // Load Data Safe
        const dataScript = document.getElementById('app-data');
        if (!dataScript) {
            console.error("No app data found");
            return;
        }
        
        let elements = [];
        try {
            elements = JSON.parse(dataScript.textContent);
        } catch(e) {
            console.error("JSON Parse Error", e);
            document.body.innerHTML = '<div style="color:red; padding:20px;">Failed to parse diagram data.</div>';
            return;
        }

        // Load Mermaid Dynamically
        let mermaid = null;
        try {
            const module = await import('https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs');
            mermaid = module.default;
            mermaid.initialize({ startOnLoad: false, securityLevel: 'loose', theme: 'default' });
        } catch(e) {
            console.warn("Mermaid failed to load", e);
        }

        const container = document.getElementById('container');
        const layer = document.getElementById('transform-layer');
        const svg = document.getElementById('canvas');
        let view = { x: 0, y: 0, zoom: 1 };

        const render = async () => {
            svg.innerHTML = '';

            // --- Auto Fit View ---
            if (elements.length > 0) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                let hasValidElements = false;

                elements.forEach(el => {
                    const ex = Number(el.x) || 0;
                    const ey = Number(el.y) || 0;
                    const ew = Number(el.width) || 0;
                    const eh = Number(el.height) || 0;

                    if (el.points && Array.isArray(el.points)) {
                        el.points.forEach(p => {
                            const px = Number(p.x) || 0;
                            const py = Number(p.y) || 0;
                            minX = Math.min(minX, ex + px);
                            minY = Math.min(minY, ey + py);
                            maxX = Math.max(maxX, ex + px);
                            maxY = Math.max(maxY, ey + py);
                        });
                        hasValidElements = true;
                    } else {
                        minX = Math.min(minX, ex);
                        minY = Math.min(minY, ey);
                        maxX = Math.max(maxX, ex + ew);
                        maxY = Math.max(maxY, ey + eh);
                        hasValidElements = true;
                    }
                });
                
                if (hasValidElements && minX !== Infinity) {
                    const padding = 100;
                    const contentW = (maxX - minX) + padding * 2;
                    const contentH = (maxY - minY) + padding * 2;
                    
                    if (contentW > 0 && contentH > 0) {
                        const scaleX = window.innerWidth / contentW;
                        const scaleY = window.innerHeight / contentH;
                        const scale = Math.min(Math.min(scaleX, scaleY), 1.5);
                        
                        const cx = (minX + maxX) / 2;
                        const cy = (minY + maxY) / 2;
                        
                        view.zoom = scale;
                        view.x = (window.innerWidth / 2) - (cx * scale);
                        view.y = (window.innerHeight / 2) - (cy * scale);
                        updateTransform();
                    }
                }
            }

            for (const el of elements) {
                try {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("transform", `translate(${el.x || 0}, ${el.y || 0})`);
                    g.style.opacity = el.opacity !== undefined ? el.opacity : 1;
                    
                    if (el.type === 'text') {
                        const fo = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                        fo.setAttribute("width", el.width || 100);
                        fo.setAttribute("height", el.height || 20);
                        fo.innerHTML = `<div class="font-hand" style="font-size: 20px; line-height: 1.2; color: ${el.strokeColor || '#000'}; white-space: pre-wrap;">${renderMarkdown(el.text || '', el.strokeColor)}</div>`;
                        g.appendChild(fo);
                    } else if (el.type === 'mermaid') {
                         // MERMAID RENDERING
                         const fo = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                         fo.setAttribute("width", el.width || 200);
                         fo.setAttribute("height", el.height || 100);
                         fo.style.overflow = "visible";
                         
                         const div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
                         div.style.width = "100%";
                         div.style.height = "100%";
                         div.style.display = "flex";
                         div.style.alignItems = "center";
                         div.style.justifyContent = "center";
                         
                         const id = 'mermaid-' + Math.random().toString(36).substr(2, 9);
                         
                         if (mermaid) {
                             try {
                                 const { svg } = await mermaid.render(id, el.text || "graph TD; Error");
                                 div.innerHTML = svg;
                                 const svgEl = div.querySelector('svg');
                                 if (svgEl) {
                                    svgEl.removeAttribute('height');
                                    svgEl.style.maxWidth = '100%';
                                 }
                             } catch(err) {
                                 console.warn("Mermaid Render Error", err);
                                 div.textContent = "Diagram Error";
                                 div.style.color = "red";
                                 div.style.fontSize = "12px";
                                 div.style.border = "1px solid red";
                             }
                         } else {
                             div.textContent = "Mermaid (Not Loaded)";
                             div.style.color = "#999";
                         }

                         fo.appendChild(div);
                         g.appendChild(fo);
                    } else {
                        const pathStr = getPath(el);
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        path.setAttribute("d", pathStr);
                        path.setAttribute("stroke", el.strokeColor || '#000');
                        path.setAttribute("fill", el.backgroundColor || 'transparent');
                        path.setAttribute("stroke-width", el.strokeWidth || 2);
                        path.setAttribute("stroke-linecap", "round");
                        path.setAttribute("stroke-linejoin", "round");
                        path.setAttribute("vector-effect", "non-scaling-stroke");
                        g.appendChild(path);

                        if (el.text) {
                            const fo = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                            fo.setAttribute("width", el.width || 100);
                            fo.setAttribute("height", el.height || 40);
                            fo.style.pointerEvents = 'none';
                            const textColor = (el.strokeColor === '#000000' && el.backgroundColor !== '#ffffff' && el.backgroundColor !== 'transparent') ? 'white' : 'black';
                            fo.innerHTML = `<div class="w-full h-full flex items-center justify-center text-center p-1 font-hand" style="font-size: 20px; color: ${textColor}">${renderMarkdown(el.text || '', textColor)}</div>`;
                            g.appendChild(fo);
                        }
                    }
                    svg.appendChild(g);
                } catch(renderErr) {
                    console.error("Error rendering element", el, renderErr);
                }
            }
        };

        const updateTransform = () => {
            if (isNaN(view.x) || isNaN(view.y) || isNaN(view.zoom)) {
                view = { x: 0, y: 0, zoom: 1 };
            }
            layer.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.zoom})`;
        };

        let isDragging = false;
        let start = { x: 0, y: 0 };

        container.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const zoomSensitivity = 0.001;
                const delta = -e.deltaY * zoomSensitivity;
                const newZoom = Math.max(0.1, Math.min(5, view.zoom + delta));
                
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const worldX = (mouseX - view.x) / view.zoom;
                const worldY = (mouseY - view.y) / view.zoom;
                
                view.x = mouseX - worldX * newZoom;
                view.y = mouseY - worldY * newZoom;
                view.zoom = newZoom;
            } else {
                view.x -= e.deltaX;
                view.y -= e.deltaY;
            }
            updateTransform();
        });

        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            container.style.cursor = 'grabbing';
            start = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - start.x;
            const dy = e.clientY - start.y;
            view.x += dx;
            view.y += dy;
            start = { x: e.clientX, y: e.clientY };
            updateTransform();
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            container.style.cursor = 'grab';
        });

        // Trigger Render
        render();
    };
    
    // Start
    init();
</script>
</body>
</html>